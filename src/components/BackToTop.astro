---
import { t } from "@/i18n/translations";

interface Props {
	targetId?: string; // 观察的目标元素ID，用于判断何时显示按钮
}

const { targetId } = Astro.props;
---

<button
	class="hover:border-link fixed end-4 bottom-8 z-90 flex h-10 w-10 translate-y-28 cursor-pointer items-center justify-center rounded-full border-2 border-transparent bg-zinc-200 text-3xl opacity-0 transition-all transition-discrete duration-300 data-[show=true]:translate-y-0 data-[show=true]:opacity-100 sm:end-8 sm:h-12 sm:w-12 dark:bg-zinc-700"
	data-show="false"
	id="back-to-top-btn"
>
	<span class="sr-only">{t("blog.backToTop")}</span>
	<svg
		aria-hidden="true"
		class="h-6 w-6"
		fill="none"
		focusable="false"
		stroke="currentColor"
		stroke-width="2"
		viewBox="0 0 24 24"
		xmlns="http://www.w3.org/2000/svg"
	>
		<path d="M4.5 15.75l7.5-7.5 7.5 7.5" stroke-linecap="round" stroke-linejoin="round"></path>
	</svg>
</button>

<script define:vars={{ targetId }}>
	const scrollBtn = document.getElementById("back-to-top-btn");
	
	if (scrollBtn) {
		// 点击滚动到顶部
		scrollBtn.addEventListener("click", () => {
			document.documentElement.scrollTo({ behavior: "smooth", top: 0 });
		});

		// 根据滚动位置显示/隐藏按钮
		if (targetId) {
			// 如果提供了目标元素ID，基于元素可见性控制
			const targetElement = document.getElementById(targetId);
			if (targetElement) {
				const observer = new IntersectionObserver((entries) => {
					entries.forEach((entry) => {
						scrollBtn.dataset.show = (!entry.isIntersecting).toString();
					});
				});
				observer.observe(targetElement);
			}
		} else {
			// 如果没有提供目标元素，基于滚动距离控制
			let lastScrollY = 0;
			
			const handleScroll = () => {
				const currentScrollY = window.scrollY;
				
				// 当滚动超过一屏高度时显示按钮
				if (currentScrollY > window.innerHeight) {
					scrollBtn.dataset.show = "true";
				} else {
					scrollBtn.dataset.show = "false";
				}
				
				lastScrollY = currentScrollY;
			};
			
			window.addEventListener("scroll", handleScroll, { passive: true });
		}
	}
</script>